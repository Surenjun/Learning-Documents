### 副作用

>只要跟函数外部环境发生交互都是副作用。函数式编程的哲学就是假定副作用是造成不正当行为的主要原因。



### 纯函数

>函数是不同数值之间的特殊关系：每一个输入值返回且只返回一个输出值。换句话说：函数只是两种数值之间的关系：输入和输出。但是不同的输入却可以有相同的输出。简单来说函数就是输入到输出的映射而已。
>
>纯函数*就是*数学上的函数，而且是函数式编程的全部。
>
>#### 追求纯的的理由：
>
>>1·可缓存性：
>>
>>```javascript
>>const memoize = function(f) {
>>const cache = {};
>>
>>return function() {
>>var arg_str = JSON.stringify(arguments);
>>    //如果传入的参数一样 就不执行函数了
>>    cache[arg_str] = cache[arg_str] || f.apply(f, arguments);
>>    return cache[arg_str];
>>	};
>>};
>>
>>const squareNumber  = memoize(function(x){ return x * x;});
>>squareNumber(5);
>>//=> 25
>>
>>squareNumber(5); // 从缓存中读取输入值为 5 的结果
>>//=> 25
>>```
>>
>>2·可移植性/自文档化
>>
>>3·可测试性能
>>
>>4·合理性
>
>函数式编程追求的是相同的输入，永远是相同的输出，而且没有任何可观察的副作用。
>
>```javascript
>let xs = [1,2,3,4,5];
>
>// 纯的
>xs.slice(0,3);
>//=> [1,2,3]
>
>xs.slice(0,3);
>//=> [1,2,3]
>
>xs.slice(0,3);
>//=> [1,2,3]
>
>
>// 不纯的
>xs.splice(0,3);
>//=> [1,2,3]
>
>xs.splice(0,3);
>//=> [4,5]
>
>xs.splice(0,3);
>//=> []
>```

### 柯里化

### 函数组合  compose

>```javascript
>const compose = function(f,g) {
>return function(x) {
>return f(g(x));
>};
>};
>
>// 结合律（associativity）
>const associative = compose(f, compose(g, h)) == compose(compose(f, g), h);
>// true
>```
>
>#### pointfree模式
>
>函数无须提及将要操作的数据是什么样的。一等公民的函数、柯里化（curry）以及组合协作起来非常有助于实现这种模式。
>
>```javascript
>// 非 pointfree，因为提到了数据：word
>const snakeCase = function (word) {
>  return word.toLowerCase().replace(/\s+/ig, '_');
>};
>
>// pointfree
>const snakeCase = compose(replace(/\s+/ig, '_'), toLowerCase);
>
>
>// 非 pointfree，因为提到了数据：name
>const initials = function (name) {
>  return name.split(' ').map(compose(toUpperCase, head)).join('. ');
>};
>
>// pointfree
>const initials = compose(join('. '), map(compose(toUpperCase, head)), split(' '));
>
>initials("hunter stockton thompson");
>// 'H. S. T'
>```
>
>

### 范畴学

### 声明式代码（函数式编程的应用）

>```javascript
>requirejs.config({
>  paths: {
>    ramda: 'https://cdnjs.cloudflare.com/ajax/libs/ramda/0.13.0/ramda.min',
>    jquery: 'https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min'
>  }
>});
>
>require([
>    'ramda',
>    'jquery'
>  ],
>  function (_, $) {
>    var Impure = {
>      getJSON: _.curry(function(callback, url) {
>        $.getJSON(url, callback);
>      }),
>
>      setHtml: _.curry(function(sel, html) {
>        $(sel).html(html);
>      })
>    };
>
>    var img = function (url) {
>      return $('<img />', { src: url });
>    };
>
>    var trace = _.curry(function(tag, x) {
>      console.log(tag, x);
>      return x;
>    });
>
>    var url = function (t) {
>      return 'https://api.flickr.com/services/feeds/photos_public.gne?tags=' + t + '&format=json&jsoncallback=?';
>    };
>
>    var mediaUrl = _.compose(_.prop('m'), _.prop('media'));
>
>    var srcs = _.compose(_.map(mediaUrl), _.prop('items'));
>
>    var images = _.compose(_.map(img), srcs);
>
>    var renderImages = _.compose(Impure.setHtml("body"), images);
>
>    var app = _.compose(Impure.getJSON(renderImages), url);
>
>    app("cats");
>  });
>```

### compse

>```javascript
>const compose =
>       (fn, ...fns) => fns.length === 0 ? fn: (...args) => fn(compose(...fns)(...args));
>const compose1 = (...fns) => fns.reduce((f, g) => (...args) => f(g(...args)));
>const pipe = (...fns) => x => fns.reduce((v, f) => f(v), x);//正向的compose
>```
>
>
>
>