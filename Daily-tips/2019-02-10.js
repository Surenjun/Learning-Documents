//1.闭包中的变量并不保存在栈内存中,而是保存在堆内存中。所以闭包能引用到函数内的变量

//2.UDP
    /*相比 TCP 简单的多，不需要建立连接，不需要验证数据报文，不需要流量控制，可能会导致丢包
    只会把想发的数据报文一股脑的丢给对端。虽然 UDP 并没有 TCP 传输来的准备，
    但是也能在很多实时性要求高的地方有所作为。*/

//3.TCP的3次握手
    //建立连接需要三次握手，断开连接需要四次握手
    //第一次握手:客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。
    //第二次握手:服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号。
    //第三次握手:当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。

///4.Get与Post
    //Get能够请求缓存,Post不能
    //Post相对Get安全一点点，因为Get请求都包含在Url里
    //Post 支持更多的编码类型且不对数据类型限制

//5.Https协议
    /*HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。
    TLS 协议位于传输层之上，应用层之下。首次进行 TLS 协议传输需要两个 RTT ，接下来可以通过 Session Resumption 减少到一个 RTT。
    在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。*/

    //HTTP/2 通过多路复用、二进制流、Header 压缩等等技术，极大地提高了性能，但是还是存在着问题的

//6.浏览器是怎么解析CSS选择器的
    /*CSS选择器的解析是从右向左解析的。若从左向右的匹配，发现不符合规则，需要进行回溯，
    会损失很多性能。若从右向左匹配，先找到所有的最右节点，对于每一个节点，
    向上寻找其父节点直到找到根元素或满足条件的匹配规则，则结束这个分支的遍历。
    两种匹配规则的性能差别很大，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），
    而从左向右的匹配规则的性能都浪费在了失败的查找上面。
    而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，
    最终用来进行绘图。在建立 Render Tree 时（WebKit 中的「Attachment」过程），
    浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 Render Tree。*/

